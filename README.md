### Code based on ATrappmann/PN5180-Library
### https://github.com/ATrappmann/PN5180-Library

## Ошибки при UID

| Реальное состояние                       | IRQ-Status   | Расшифровка                                                                                  |
|------------------------------------------|--------------|----------------------------------------------------------------------------------------------|
| OK                                       | 0x24007      | RQ TX IDLE RX_SOF_DET GENERAL_ERROR                                                          |
| Отключено питание 5180                   | 0x66066706   | TX IDLE TX_RFOFF TX_RFON RF_ACTIVE_ERROR TIMER2 RX_SOF_DET GENERAL_ERROR HV_ERROR            |
| Питание 5180 включено после отключения   | 0x20006      | TX IDLE GENERAL_ERROR                                                                        |
| Было приложено более 2-х карт            | 0x66066706   | TX IDLE TX_RFOFF TX_RFON RF_ACTIVE_ERROR TIMER2 RX_SOF_DET GENERAL_ERROR HV_ERROR            |

---

- При напряжении на антенне **5,25 В** дальность обнаружения карты — **7 см** (оптимально).
- При напряжении на антенне **5,80 В** дальность обнаружения карты — **6,5 см**.

---

### Подробный алгоритм работы программы (`main.cpp`)

#### 1. `setup()`
- Вызывается Arduino при старте.
- Устанавливает режим пина питания PN5180:  
    `pinMode(PIN_TRIGGER, OUTPUT)`
- Инициализирует Serial-порт:  
    `Serial.begin(9600)`
- Запускает цикл инициализации PN5180:
    - В цикле вызывает `PN5180ISO14443_start()`.
    - Если возвращает `false`, выводит ошибку, ждёт 1 секунду и повторяет попытку.

#### 2. `PN5180ISO14443_start()`
- Отключает питание PN5180:  
    `digitalWrite(PIN_TRIGGER, LOW)`
- Выводит служебную информацию в Serial.
- Включает питание PN5180:  
    `digitalWrite(PIN_TRIGGER, HIGH)`
- Ждёт 30 мс.
- Вызывает:
    - `nfc.begin()` — инициализация SPI и пинов.
    - `nfc.reset()` — аппаратный сброс PN5180.
    - `nfc.readEEprom(PRODUCT_VERSION, ...)` — читает версию продукта.
        - Если версия не совпадает с ожидаемой — возвращает `false`.
    - `nfc.readEEprom(FIRMWARE_VERSION, ...)` — читает версию прошивки.
    - `nfc.readEEprom(EEPROM_VERSION, ...)` — читает версию EEPROM.
    - `nfc.setupRF()` — загружает RF-конфигурацию и включает RF-поле.
- Возвращает `true` при успехе.

#### 3. `loop()`
- Вызывается Arduino постоянно.
- Если установлен `errorFlag`:
    - Вызывает `nfc.getIRQStatus()` — получает IRQ-статус.
    - Вызывает `showIRQStatus(irqStatus)` — расшифровывает и выводит IRQ-статус.
    - Если карта не обнаружена (`RX_SOF_DET_IRQ_STAT & irqStatus == 0`), выводит сообщение.
    - Вызывает `nfc.reset()` и `nfc.setupRF()` — сбрасывает и повторно инициализирует PN5180.
    - Сбрасывает `errorFlag`, ждёт 10 мс.
- Выводит разделитель и номер цикла.
- Проверяет наличие карты:  
    `nfc.isCardPresent()`
    - Внутри вызывает `nfc.readCardSerial(buffer)`.
    - Если карты нет:
        - Выводит сообщение, получает и выводит IRQ-статус.
        - Если IRQ-статус не равен `0x24007` — устанавливает `errorFlag`.
        - Ждёт 300 мс и завершает итерацию.
- Читает UID карты:  
    `nfc.readCardSerial(uid)`
    - Если не удалось — выводит ошибку, устанавливает `errorFlag`, завершает итерацию.
    - Иначе выводит UID.
- Выводит разделитель.
- Готовит ключ по умолчанию (Key A) и буфер для сектора.
- Выбирает сектор и первый блок сектора.
- Ждёт 1.5 секунды.

#### 4. `nfc.readCardSerial(uid)`
- Внутри вызывает `activateTypeA(response, 1)` — активация карты и получение UID.
- Проверяет корректность ответа.
- Копирует UID в буфер.
- Вызывает `mifareHalt()` — завершает обмен с картой.
- Возвращает длину UID.

#### 5. `nfc.isCardPresent()`
- Внутри вызывает `readCardSerial(buffer)`.
- Если длина UID >= 4 — карта есть.

#### 6. `nfc.mifareAuthenticate(block, keyType, key, uid, uidLen)`
- Формирует команду аутентификации (ключ, блок, UID).
- Вызывает `sendData(cmd, 12, 0x00)` — отправляет команду на карту.
- Возвращает результат.

#### 7. `readMifareSector(sectorNumber, buffer)`
- Для каждого из 4 блоков сектора:
    - Вызывает `nfc.mifareBlockRead(block, buffer)` — читает блок.
    - Если ошибка — возвращает `false`.
- Если все успешно — возвращает `true`.

#### 8. `showIRQStatus(irqStatus)`
- Расшифровывает биты IRQ-статуса и выводит их в Serial.

---

#### Взаимосвязь функций (упрощённая схема):

setup()
  └─> PN5180ISO14443_start()
        ├─> nfc.begin()
        ├─> nfc.reset()
        ├─> nfc.readEEprom()
        └─> nfc.setupRF()

loop()
  ├─> nfc.getIRQStatus()
  ├─> showIRQStatus()
  ├─> nfc.reset()
  ├─> nfc.setupRF()
  ├─> nfc.isCardPresent()
        └─> nfc.readCardSerial()
              ├─> activateTypeA()
              └─> mifareHalt()
  ├─> nfc.readCardSerial()
  ├─> nfc.mifareAuthenticate()


| Значение ATQA | Тип карты              | UID           |
| ------------- | ---------------------- | ------------- |
| `0x0004`      | MIFARE Ultralight      | 7-байтный UID |
| `0x0400`      | MIFARE Classic 1K      | 4-байтный UID |
| `0x4400`      | MIFARE DESFire EV1/EV2 | 7-байтный UID |
| `0x0800`      | MIFARE Classic 4K      | 7-байтный UID |
| `0x0044`      | NFC Forum Type 2       | 7-байтный UID |


| Значение SAK | Тип карты                                             | Примечания                     |
| ------------ | ----------------------------------------------------- | ------------------------------ |
| `0x08`       | **MIFARE Classic 1K**                                 | Также бывает у UL              |
| `0x18`       | **MIFARE Classic 4K**                                 |                                |
| `0x20`       | **MIFARE DESFire (EV1/EV2)**                          | Стандартный признак            |
| `0x28`       | **MIFARE Plus SL1**                                   | (в режиме backward compatible) |
| `0x40`       | **ISO/IEC 14443-4 card**                              | Может быть NDEF / DESFire      |
| `0x00`       | **MIFARE Ultralight / Type A tag**                    | Самые простые                  |
| `0x88`       | UID не завершён, нужно еще ANTICOLL (cascade level 2) |                                |



### Общий алгоритм работы с защищёнными страницами MIFARE Ultralight EV1

GitHub Copilot: ### Общий алгоритм работы с защищёнными страницами MIFARE Ultralight EV1

1. **Инициализация**  
   Настройка стека NFC, выбор карты, получение UID.

2. **Аутентификация (если страница защищена):**  
   - Для Ultralight EV1 используется команда `PWD_AUTH` (`0x1B`), а для некоторых операций — `AUTH` (`0x1A`).
   - Перед аутентификацией нужно знать пароль (PWD) и ожидаемый ответ (PACK).
   - Отправляется команда аутентификации с паролем, карта возвращает PACK, который сравнивается с ожидаемым.

3. **Чтение/запись страниц:**  
   - После успешной аутентификации можно читать (`READ`, `0x30`) или писать (`WRITE`, `0xA2`) защищённые страницы.
   - Для ускоренного чтения используется `FAST_READ` (`0x3A`), для ускоренной записи — `FAST_WRITE` (`0xA6`).

4. **Завершение работы:**  
   - При необходимости сбросить сессию или перейти к другой карте.

---

### Основные команды MIFARE Ultralight EV1 (по коду и назначению)

| Команда                | Код   | Описание                                      |
|------------------------|-------|-----------------------------------------------|
| READ                   | 0x30  | Чтение 4 страниц                             |
| WRITE                  | 0xA2  | Запись 1 страницы (4 байта)                  |
| COMPATIBILITY WRITE    | 0xA0  | Совместимая запись (старые карты)            |
| FAST_WRITE             | 0xA6  | Быстрая запись нескольких страниц            |
| FAST_READ              | 0x3A  | Быстрое чтение диапазона страниц             |
| PWD_AUTH               | 0x1B  | Аутентификация по паролю                     |
| AUTH                   | 0x1A  | Аутентификация (расширенная, EV1)            |
| GET_VERSION            | 0x60  | Получить версию чипа                         |
| INCR_CNT               | 0xA5  | Инкремент счетчика                           |
| READ_CNT               | 0x39  | Прочитать счетчик                            |
| SECTOR_SELECT          | 0xC2  | Переключение сектора                         |
| READ_SIG               | 0x3C  | Прочитать цифровую подпись                   |
| CHK_TRG_EVT            | 0x3E  | Проверка tearing event                       |
| WRITE_SIGN             | 0xA9  | Запись подписи                               |
| LOCK_SIGN              | 0xAC  | Блокировка подписи                           |
| VIRTUAL_CARD_SELECT    | 0x4B  | Виртуальная карта                            |
| READ_TT_STATUS         | 0xA4  | Статус TT                                    |

---

**Пример последовательности для защищённой страницы:**
1. Получить версию карты (`GET_VERSION`).
2. Выполнить аутентификацию (`PWD_AUTH` или `AUTH`).
3. Прочитать или записать нужную страницу (`READ`/`WRITE`).
4. При необходимости — другие команды (например, счетчики, подпись).



> **Важно!**  
>  
> При записи конфигурационных страниц MIFARE Ultralight EV1 (например, для установки пароля и защиты) нельзя изменять все параметры сразу — карта может не принять изменения или перейти в некорректное состояние.  
>  
> **Рекомендуемый пошаговый порядок записи:**
>
> 1. **Запись PACK (страница 0x13):**  
>    ```cpp
>    mifareUltralightWrite(0x13, pack); // PACK для защиты
>    ```
>    Проверьте, что PACK успешно записан.
>
> 2. **Запись пароля (PWD, страница 0x12):**  
>    ```cpp
>    mifareUltralightWrite(0x12, pwd); // Пароль для защиты
>    ```
>    Проверьте, что пароль успешно записан.
>
> 3. **Установка флага защиты (PROT, страница 0x11):**  
>    ```cpp
>    mifareUltralightWrite(0x11, cfg1); // PROT=1 — защита чтения и записи
>    ```
>    Проверьте изменения.
>
> 4. **Установка начальной страницы защиты (AUTH0, страница 0x10):**  
>    ```cpp
>    mifareUltralightWrite(0x10, cfg0); // AUTH0=0x0F — защита со страницы ...
>    ```
>
> После каждого шага рекомендуется читать страницу и проверять, что изменения применились корректно.
